(function (global, factory) {
    if (typeof define === "function" && define.amd) {
        define(['exports', 'warning'], factory);
    } else if (typeof exports !== "undefined") {
        factory(exports, require('warning'));
    } else {
        var mod = {
            exports: {}
        };
        factory(mod.exports, global.warning);
        global.utilities = mod.exports;
    }
})(this, function (exports, _warning) {
    'use strict';

    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.whenValueIs = exports.toString = exports.toNumber = exports.isUndefined = exports.isString = exports.isObjectLike = exports.isObject = exports.isNumber = exports.isNull = exports.isNil = exports.isFunction = exports.isEmptyString = exports.isBoolean = exports.isArray = exports.isInvalidType = exports.typeToString = exports.objectToTag = exports.functionToTag = exports.getType = exports.Types = exports.INVALID_TYPE = undefined;

    var _warning2 = _interopRequireDefault(_warning);

    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }

    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
        return typeof obj;
    } : function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };

    var _slicedToArray = function () {
        function sliceIterator(arr, i) {
            var _arr = [];
            var _n = true;
            var _d = false;
            var _e = undefined;

            try {
                for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                    _arr.push(_s.value);

                    if (i && _arr.length === i) break;
                }
            } catch (err) {
                _d = true;
                _e = err;
            } finally {
                try {
                    if (!_n && _i["return"]) _i["return"]();
                } finally {
                    if (_d) throw _e;
                }
            }

            return _arr;
        }

        return function (arr, i) {
            if (Array.isArray(arr)) {
                return arr;
            } else if (Symbol.iterator in Object(arr)) {
                return sliceIterator(arr, i);
            } else {
                throw new TypeError("Invalid attempt to destructure non-iterable instance");
            }
        };
    }();

    var INVALID_TYPE = exports.INVALID_TYPE = 'Invalid type, see console for details.';

    var NEGATIVE_REGEXP = /^-/;

    var Types = exports.Types = Object.freeze({
        array: Array,
        boolean: Boolean,
        function: Function,
        null: null,
        number: Number,
        object: Object,
        string: String,
        undefined: undefined
    });

    var getType = exports.getType = function getType(value) {
        return Object.entries({
            array: isArray,
            boolean: isBoolean,
            function: isFunction,
            null: isNull,
            number: isNumber,
            object: isObject,
            string: isString,
            undefined: isUndefined
        }).reduce(function (type, _ref) {
            var _ref2 = _slicedToArray(_ref, 2),
                key = _ref2[0],
                isType = _ref2[1];

            return type !== false || !isType(value) ? type : Types[key];
        }, false);
    };

    var functionToTag = exports.functionToTag = function functionToTag(func) {
        return Function.prototype.toString.call(func);
    };

    var objectToTag = exports.objectToTag = function objectToTag(obj) {
        return Object.prototype.toString.call(obj);
    };

    var typeToString = exports.typeToString = function typeToString(type) {
        return isFunction(type) ? functionToTag(type).match(/^function (\w+)/)[1] : objectToTag(type).match(/^\[object (\w+)/)[1];
    };

    var isInvalidType = exports.isInvalidType = function isInvalidType(value, validTypes) {
        var type = getType(value);
        var isValid = validTypes.includes(type);

        process.env.NODE_ENV !== 'production' ? (0, _warning2.default)(isValid, 'Invalid value type "%s", expected value type%s: %s', typeToString(type), validTypes.length > 1 ? 's' : '', validTypes.map(typeToString).join(', ')) : void 0;

        return !isValid && process.env.NODE_ENV !== 'production' ? INVALID_TYPE : null;
    };

    var isArray = exports.isArray = function isArray(value) {
        return Array.isArray(value);
    };

    var isBoolean = exports.isBoolean = function isBoolean(value) {
        return typeof value === 'boolean' || isObjectLike(value) && objectToTag(value) === '[object Boolean]';
    };

    var isEmptyString = exports.isEmptyString = function isEmptyString(value) {
        return isString(value) && value.trim().length === 0;
    };

    var isFunction = exports.isFunction = function isFunction(value) {
        return typeof value === 'function';
    };

    var isNil = exports.isNil = function isNil(value) {
        return isNull(value) || isUndefined(value);
    };

    var isNull = exports.isNull = function isNull(value) {
        return value === null;
    };

    var isNumber = exports.isNumber = function isNumber(value) {
        return (typeof value === 'number' || isObjectLike(value) && objectToTag(value) === '[object Number]') && !isNaN(value);
    };

    var isObject = exports.isObject = function isObject(value) {
        if (!isObjectLike(value) || objectToTag(value) !== '[object Object]') {
            return false;
        }

        var prototype = Object.getPrototypeOf(Object(value));

        if (isNull(prototype)) {
            return true;
        }

        var Ctor = Object.prototype.hasOwnProperty.call(prototype, 'constructor') && prototype.constructor;

        return isFunction(Ctor) && Ctor instanceof Ctor && functionToTag(Ctor) === functionToTag(Object);
    };

    var isObjectLike = exports.isObjectLike = function isObjectLike(value) {
        return !isNull(value) && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object';
    };

    var isString = exports.isString = function isString(value) {
        return typeof value === 'string' || isObjectLike(value) && objectToTag(value) === '[object String]';
    };

    var isUndefined = exports.isUndefined = function isUndefined(value) {
        return value === undefined;
    };

    var toNumber = exports.toNumber = function toNumber(value) {
        return isNumber(value) || isString(value) && !isEmptyString(value) ? Number(value) : NaN;
    };

    var toString = exports.toString = function toString(value) {
        return isArray(value) || isObject(value) ? JSON.stringify(value) : '' + value;
    };

    var whenValueIs = exports.whenValueIs = function whenValueIs(value, _ref3, model) {
        var lessThan = _ref3.lessThan,
            equalTo = _ref3.equalTo,
            greaterThan = _ref3.greaterThan;

        if (isNumber(value) || isString(value)) {
            value = ('' + value).trim();
            model = ('' + model).trim();

            var valueIsNegative = NEGATIVE_REGEXP.test(value);
            var modelIsNegative = NEGATIVE_REGEXP.test(model);

            if (valueIsNegative && !modelIsNegative) {
                return lessThan;
            }

            if (!valueIsNegative && modelIsNegative) {
                return greaterThan;
            }

            value = value.replace(NEGATIVE_REGEXP, '');
            model = model.replace(NEGATIVE_REGEXP, '');

            var _value$split = value.split('.'),
                _value$split2 = _slicedToArray(_value$split, 2),
                valInt = _value$split2[0],
                _value$split2$ = _value$split2[1],
                valDec = _value$split2$ === undefined ? '' : _value$split2$;

            var _model$split = model.split('.'),
                _model$split2 = _slicedToArray(_model$split, 2),
                modInt = _model$split2[0],
                _model$split2$ = _model$split2[1],
                modDec = _model$split2$ === undefined ? '' : _model$split2$;

            var intLength = Math.max(valInt.length, modInt.length);
            var decLength = Math.max(valDec.length, modDec.length);

            valInt = valInt.padStart(intLength, '0');
            modInt = modInt.padStart(intLength, '0');

            valDec = valDec.padEnd(decLength, '0');
            modDec = modDec.padEnd(decLength, '0');

            value = valInt + '.' + valDec;
            model = modInt + '.' + modDec;

            if (value === model) {
                return equalTo;
            }

            return (valueIsNegative && modelIsNegative ? value > model : value < model) ? lessThan : greaterThan;
        }

        return isInvalidType(value, [Types.number, Types.string]);
    };
});