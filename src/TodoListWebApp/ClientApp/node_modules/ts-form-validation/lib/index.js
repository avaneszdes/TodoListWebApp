"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.formHaveMessagesOfType = exports.validateForm = exports.FormValidationMessageCode = exports.MessageType = exports.initForm = exports.DEFAULT_ERRORMESSAGE_FIELD_IS_REQUIRED = void 0;
/**
 * # ts-form-validation
 *
 * A simple form validation library for typescript users.
 *
 * @author Ville Venäläinen / Mindhive Oy
 */
var deepmerge_1 = __importDefault(require("deepmerge"));
exports.DEFAULT_ERRORMESSAGE_FIELD_IS_REQUIRED = 'This field is required';
/**
 * Initialize form with default set
 */
var initForm = function (values, rules, filled) {
    if (filled === void 0) { filled = {}; }
    return ({
        values: values,
        filled: filled,
        messages: {},
        rules: rules,
        isFormValid: false,
    });
};
exports.initForm = initForm;
var MessageType;
(function (MessageType) {
    /**
     * Field or form contains an error. If any validator, will return a message with this
     * code, the form will be treated as invalid.
     */
    MessageType["ERROR"] = "error";
    /**
     * Field or form contains a state for what user should be warned. Form can still to
     * be valid event if it contains warnings.
     */
    MessageType["WARNING"] = "warning";
    /**
     * Field or form contains a state for what user should be hinted. Form can be treaded valid
     * when containing this kind of messages.
     */
    MessageType["HINT"] = "hint";
    /**
     * Error message given, when validator callback fails with the exception. Exception error
     * message will be included into message.
     */
    MessageType["VALIDATION_ERROR"] = "validation_error";
})(MessageType = exports.MessageType || (exports.MessageType = {}));
var FormValidationMessageCode;
(function (FormValidationMessageCode) {
    FormValidationMessageCode[FormValidationMessageCode["NONE"] = 0] = "NONE";
    FormValidationMessageCode[FormValidationMessageCode["FIELD_IS_REQUIRED"] = 1] = "FIELD_IS_REQUIRED";
    FormValidationMessageCode[FormValidationMessageCode["CUSTOM"] = 100] = "CUSTOM";
    FormValidationMessageCode[FormValidationMessageCode["INTERNAL_FIELD_NOT_FOUND"] = 1000] = "INTERNAL_FIELD_NOT_FOUND";
    FormValidationMessageCode[FormValidationMessageCode["INTERNAL_ERROR"] = 9999] = "INTERNAL_ERROR";
})(FormValidationMessageCode = exports.FormValidationMessageCode || (exports.FormValidationMessageCode = {}));
/**
 * Make a deep copy of an object. If there is no value an empty object will be created
 */
function deepcopy(value) {
    return value ? deepmerge_1.default(value, {}) : {};
}
/**
 * Validate form input against a defined rules
 *
 * @export
 * @template T Type of form fields
 *
 * @param form The form info for controlling validation
 * @param options: Extra options to control validation process
 * @returns {ValidatedForm<T>}
 */
// tslint:disable-next-line: cognitive-complexity
function validateForm(form, options) {
    if (options === void 0) { options = { usePreprocessor: true }; }
    var formCopy = {
        filled: deepcopy(form.filled),
        values: deepcopy(form.values),
        rules: form.rules,
        messages: {},
        isFormValid: false,
    };
    var rules = formCopy.rules;
    var values = formCopy.values;
    // filled can not be undefined here because of deepcopy above but typescript doesn't notice that
    var filled = formCopy.filled;
    if (options.setFilled) {
        if (Array.isArray(options.setFilled)) {
            for (var _i = 0, _a = options.setFilled; _i < _a.length; _i++) {
                var fieldKey = _a[_i];
                filled[fieldKey] = true;
            }
        }
        else {
            switch (typeof options.setFilled) {
                case 'string':
                    filled[options.setFilled] = true;
                    break;
                case 'object':
                    formCopy.filled = filled = __assign(__assign({}, filled), options.setFilled);
                    break;
                default:
                    throw new Error('Unexped type for setFilled. Should be an array of strings or a single string pointing to value field.');
            }
        }
    }
    if (options.setValues) {
        formCopy.values = values = __assign(__assign({}, values), options.setValues);
    }
    // TODO refactor in to sub functions
    var messages = {};
    var isFormValid = true;
    if (rules.fields) {
        for (var fieldKey in rules.fields) {
            var key = fieldKey;
            var validator = rules.fields[key];
            if (validator !== undefined) {
                var field = values[key];
                // Do preprocessing first
                // tslint:disable-next-line: no-useless-cast
                var value = options.usePreprocessor !== false ? preprocessFormValue(validator, field) : field;
                values[key] = value;
                // Check if required field
                if (validator.required && (value === undefined || (typeof value === 'string' && value.length === 0))) {
                    if (filled[key]) {
                        messages[key] = getRequiredFieldErrorMessage(rules, key);
                    }
                    isFormValid = false;
                    continue;
                }
                // Custom validation
                if (validator.validate) {
                    var validationResult = validator.validate(value, options.data);
                    switch (typeof validationResult) {
                        case 'boolean':
                            if (validationResult === false) {
                                console.warn("validate method's notation have been changed to true | ValidationMessage since 2.0. Please refactor the validation methods to new notation.");
                            }
                            break;
                        case 'object':
                            if (filled[fieldKey]) {
                                messages[fieldKey] = validationResult;
                            }
                            if (isFormValid) {
                                isFormValid = validationResult.type !== MessageType.ERROR;
                            }
                            break;
                        default:
                            throw new Error("Unexpected return type from " + fieldKey + " -validator: " + typeof validationResult);
                    }
                }
            }
        }
    }
    if (rules.validateForm) {
        // Erase possible old form message
        delete formCopy.formMessage;
        var result = rules.validateForm({ isFormValid: isFormValid, values: values, filled: filled }, options.data);
        if (result === true) {
            return __assign(__assign({}, formCopy), { isFormValid: isFormValid,
                filled: filled,
                values: values, messages: __assign({}, messages) });
        }
        if (result.formMessage && result.isFormValid) {
            result.isFormValid = result.formMessage.type !== MessageType.ERROR;
        }
        return __assign(__assign(__assign({}, formCopy), result), { filled: filled,
            values: values, messages: __assign(__assign({}, messages), result.messages) });
    }
    return __assign(__assign({}, formCopy), { values: values,
        filled: filled,
        messages: messages,
        isFormValid: isFormValid });
}
exports.validateForm = validateForm;
/**
 * Checks if form has specific type of messages included.
 *
 * @param response Form response object
 * @param type Message type type be checked
 */
var formHaveMessagesOfType = function (response, type) {
    if (response.messages) {
        for (var key in response.messages) {
            var field = response.messages[key];
            if (field && field.type === MessageType.ERROR) {
                return true;
            }
        }
    }
    return false;
};
exports.formHaveMessagesOfType = formHaveMessagesOfType;
function getRequiredFieldErrorMessage(rules, fieldKey) {
    try {
        var fields = rules.fields || {};
        var field = fields[fieldKey];
        if (!field) {
            return {
                type: MessageType.VALIDATION_ERROR,
                code: FormValidationMessageCode.INTERNAL_FIELD_NOT_FOUND,
                message: '',
            };
        }
        var message = field.requiredText ||
            (rules.defaultMessages && rules.defaultMessages.requiredField) ||
            exports.DEFAULT_ERRORMESSAGE_FIELD_IS_REQUIRED;
        if (typeof message === 'function') {
            message = message();
        }
        return {
            type: MessageType.ERROR,
            code: FormValidationMessageCode.FIELD_IS_REQUIRED,
            message: message,
        };
    }
    catch (error) {
        return {
            type: MessageType.VALIDATION_ERROR,
            code: FormValidationMessageCode.INTERNAL_ERROR,
            message: error,
        };
    }
}
/**
 * Do proprocessing for the field value
 *
 * @param {(FieldValidator | undefined)} validator
 * @param {*} value
 * @returns Preprocessed value
 */
function preprocessFormValue(validator, value) {
    if (!value) {
        return value;
    }
    if (validator.trim && typeof value === 'string') {
        value = value.trim();
    }
    if (validator.preprocess) {
        value = validator.preprocess(value);
    }
    return value;
}
//# sourceMappingURL=index.js.map